ğŸ§± Checkpoint 2.3 â€” The Event Bus & Decoupling
ğŸ¯ Mission:
Youâ€™ll replace tightly coupled code with an event-driven design.
Think: no more â€œA calls B which calls Câ€ â€” instead, A emits an event, and B/C subscribe to react.

This is how real UI frameworks, game engines, and modular systems scale.

ğŸ’¡ Scenario: Mini Notification System
Youâ€™ll build:

A publish/subscribe (pub/sub) event bus

Two components:

A TaskManager that can add/complete tasks

A Logger that listens and logs changes

Youâ€™ll decouple them using your event bus

ğŸ›  Features:
The TaskManager can:

Add a task (e.g., â€œFight demonsâ€)

Mark a task as done

Emit an event like: { type: "task:added", title: "Fight demons" }

The Logger listens and:

Logs to screen when a task is added or completed

ğŸ”§ Step 1: Build the Bus

function createEventBus() {
  const listeners = {};

  function on(eventType, callback) {
    if (!listeners[eventType]) {
      listeners[eventType] = [];
    }
    listeners[eventType].push(callback);
  }

  function emit(eventType, payload) {
    if (listeners[eventType]) {
      listeners[eventType].forEach(cb => cb(payload));
    }
  }

  return { on, emit };
}
ğŸ”§ Step 2: Hook It All Up

const bus = createEventBus();

// Task Manager emits events
const taskManager = {
  tasks: [],
  addTask(title) {
    this.tasks.push({ title, done: false });
    bus.emit("task:added", { title });
  },
  completeTask(title) {
    const task = this.tasks.find(t => t.title === title);
    if (task) {
      task.done = true;
      bus.emit("task:completed", { title });
    }
  }
};

// Logger listens
bus.on("task:added", ({ title }) => {
  logToScreen(`Task added: ${title}`);
});

bus.on("task:completed", ({ title }) => {
  logToScreen(`Task completed: ${title}`);
});
ğŸ¯ Your Deliverable:
A single HTML file with:

A form to add tasks

A button to mark them done

A log display (like a <ul> or <pre>)

All interaction goes through the bus. No direct method calls between modules.

ğŸ“ Bonus:
Add a counter that shows â€œX tasks completedâ€

Use the event bus to update it

Style it however you like

ğŸ§  Why This Matters:
Youâ€™re simulating:

How Redux/EventEmitters/Vue/React context work

Clean separation of logic â†’ output

A system that scales across modules/components

