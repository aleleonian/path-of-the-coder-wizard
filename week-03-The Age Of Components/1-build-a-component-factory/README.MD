ğŸ§™â€â™‚ï¸ Path of the Coder Wizard â€” Track A, Week 3 Briefing

ğŸ–ï¸ Welcome to Week 3: The Age of Components

You've now mastered:

State

Rendering

Events
Now it's time to unify those powers.

ğŸ§± Checkpoint 3.1 â€” Build a Component Factory
ğŸ¯ Mission:
Youâ€™ll build a basic system to define and render reusable components â€” with state and UI logic bundled together.

Think:

A system where you can say createCounter() and it returns a self-contained widget that:

Manages its own internal state

Can be mounted in the DOM

Updates itself when state changes

ğŸ›  Deliverable:
A reusable createComponent() function that returns an object with at least:

js
Copy
Edit
{
  mount(targetEl),      // appends the rendered DOM
  setState(newState),   // updates state and re-renders
  getState(),           // optional, for inspection
}
Youâ€™ll use this to build at least two components, for example:

âœ… A Counter: + / - buttons, shows current value

âœ… A Toggle: on/off switch

They must be:

âœ… Reusable (you can create 3 counters if you want)

âœ… Isolated (each instance has its own state)

âœ… Declarative (render logic depends only on state)

âš ï¸ Rules of Engagement
You must not rely on any framework â€” no React, Vue, etc.

You may use the EventBus from 2.3 if you want components to talk to each other â€” but itâ€™s optional

Use vanilla JS only

Your components must own their render logic â€” not depend on global DOM hacks

ğŸ“ Bonus Objectives:
Add props support (e.g., createCounter({ initialValue: 5 }))

Add destroy/unmount support (destroy() or unmount())

ğŸ§  Why This Matters
Youâ€™ll understand:

How React, Vue, and others structure components internally

Why local state + declarative render = composability

How to scale UIs with encapsulation and reuse

Ready to accept the mission? Want a starting code snippet or skeleton?