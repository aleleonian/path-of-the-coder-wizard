ğŸ›¡ï¸ Assignment: Refactor the Spaghetti Counter
ğŸ¯ Objective:
Youâ€™re handed a poorly written â€œcounter appâ€ that:

Mixes UI and logic

Has bad state management

Isnâ€™t modular

Canâ€™t be tested

Breaks when a second counter is added

Youâ€™ll:

Fix the design

Modularize logic

Separate state, view, and events

Prepare it for reusability

ğŸ§© Step 1: Here's the Spaghetti
Youâ€™ll recreate this bad code exactly first (in a single HTML file):

<h1>Counter</h1>
<p id="count">0</p>
<button onclick="inc()">+</button>
<button onclick="dec()">-</button>

<script>
  let count = 0;

  function update() {
    document.getElementById('count').textContent = count;
  }

  function inc() {
    count++;
    update();
  }

  function dec() {
    count--;
    update();
  }
</script>
Looks fine at first, but:

State is global

No separation of concerns

Can't scale to multiple counters

No error boundaries

Can't plug in logic from elsewhere

Not testable

ğŸ”¨ Step 2: Refactor It
Your Mission:
Write a createCounter() function that:

Returns a self-contained counter instance

Manages its own state (not global)

Hooks into a specific DOM element

Exposes optional onChange callback

Allow creation of multiple counters on the same page with isolated state

Keep UI/logic/state cleanly separated

âœ… Final Output Should Allow This:

const counter1 = createCounter(document.getElementById('counter1'));
const counter2 = createCounter(document.getElementById('counter2'));
And each counter behaves independently.
All state is private â€” no shared global.

ğŸ’¡ Extras (Optional):
Add reset() method

Add keyboard support

Track history of changes

ğŸ§™â€â™‚ï¸ When You're Done:
Drop the code here. Iâ€™ll review it like a senior reviewing a shared component.

Weâ€™ll make it testable, scalable, and bug-resistant.

Take the field, Lieutenant.
Refactor the spaghetti. Make it modular.
Iâ€™ll be here.ğŸ§ âš”ï¸